start: (import_stmt | globalvar | procedure_def | globalvar_decl | procedure_decl)*
start_header: (import_stmt | globalvar_decl | procedure_decl)*

// core language

globalvar: _EXPORT? _VAR variable _COLON type _EQUALS (expression | array_def) _SEMICOLON

globalvar_decl: _EXTERN _VAR variable _COLON type _SEMICOLON

import_stmt: _IMPORT ESCAPED_STRING _SEMICOLON

procedure_decl: _EXTERN procedure_prototype

procedure_def: _EXPORT? procedure_prototype (_VARS procedure_def_var*)? _BEGIN block _END

procedure_prototype: _PROCEDURE IDENTIFIER _LPAREN (procedure_prototype_arg (_COMMA procedure_prototype_arg)*)? _RPAREN _COLON type _SEMICOLON
procedure_prototype_arg: IDENTIFIER _COLON type

procedure_def_var: IDENTIFIER _COLON type _SEMICOLON

?type: type_pointer | type_name | type_array
type_name: IDENTIFIER
type_pointer: _POINTER _TO type
type_array: _ARRAY _LBRACKET NUMBER _RBRACKET _OF type

array_def: _LBRACKET (expression (_COMMA expression)*)? _RBRACKET

pointer_index: variable _LBRACKET expression _RBRACKET

// based on: https://en.cppreference.com/w/c/language/operator_precedence.html
?expression: logical_or

?logical_or: logical_and
           | logical_or LOGICAL_OR logical_and -> binop

?logical_and: bitor
            | logical_and LOGICAL_AND bitor -> binop

?bitor: bitxor
      | bitor BW_OR bitxor -> binop

?bitxor: bitand
       | bitxor BW_XOR bitand -> binop

?bitand: equality
       | bitand BW_AND equality -> binop

?equality: compare 
         | equality CMP_EQ compare -> comparison
         | equality CMP_NEQ compare -> comparison

?compare: bitshift
        | compare CMP_LT bitshift -> comparison
        | compare CMP_GT bitshift -> comparison
        | compare CMP_LTEQ bitshift -> comparison
        | compare CMP_GTEQ bitshift -> comparison

?bitshift: sum
         | bitshift BW_SHIFT_LEFT sum -> binop
         | bitshift BW_SHIFT_RIGHT sum -> binop

?sum: product
    | sum PLUS product -> binop
    | sum MINUS product -> binop

?product: unary
        | product MULTIPLY unary -> binop
        | product DIVIDE unary -> binop
        | product REMAINDER unary -> binop

?unary: atom
      | BW_NOT unary -> unaryop

?atom: variable
     | pointer_index
     | procedure_call
     | _LPAREN expression _RPAREN
     | constant

variable: IDENTIFIER

constant: HEX_NUMBER | SIGNED_INT | ESCAPED_STRING

procedure_call: IDENTIFIER _LPAREN (expression (_COMMA expression)*)* _RPAREN

assignment: (variable | pointer_index) _EQUALS expression _SEMICOLON

return: _RETURN expression _SEMICOLON

while: _WHILE expression _DO block _DONE

if: _IF expression _THEN block (_ELSIF expression _THEN block)* (_ELSE block)? _END

?statement: assignment | return | while | if | (procedure_call _SEMICOLON)

block: statement*

// keywords and terms and stuff

// keywords
_IMPORT: "IMPORT"
_EXTERN: "EXTERN"
_EXPORT: "EXPORT"
_VAR: "VAR"
_PROCEDURE: "PROCEDURE"
_VARS: "VARS"
_BEGIN: "BEGIN"
_END: "END"
_WHILE: "WHILE"
_DO: "DO"
_DONE: "DONE"
_IF: "IF"
_THEN: "THEN"
_ELSIF: "ELSIF"
_ELSE: "ELSE"
_RETURN: "RETURN"
_POINTER: "POINTER"
_TO: "TO"
_ARRAY: "ARRAY"
_OF: "OF"

// simple terms
_SEMICOLON: ";"
_COLON: ":"
_COMMA: ","
_LPAREN: "("
_RPAREN: ")"
_LBRACKET: "["
_RBRACKET: "]"
_EQUALS: "="
PLUS: "+"
MINUS: "-"
MULTIPLY: "*"
DIVIDE: "/"
REMAINDER: "%"
BW_SHIFT_LEFT: "<<"
BW_SHIFT_RIGHT: ">>"
BW_AND: "&"
BW_NOT: "~"
BW_OR: "|"
BW_XOR: "^"
CMP_LT: "<"
CMP_GT: ">"
CMP_LTEQ: "<="
CMP_GTEQ: ">="
CMP_EQ: "=="
CMP_NEQ: "!="
LOGICAL_AND: "&&"
LOGICAL_OR: "||"

// other stuff, no idea what u call this
HEX_NUMBER.1: /0x[0-9a-fA-F]+/
IDENTIFIER: /[a-zA-Z_][a-zA-Z0-9_]*/
COMMENT: "//" /[^\n]/*

// imports etc.

%import common.ESCAPED_STRING
%import common.SIGNED_INT
%import common.NUMBER
%import common.WS

%ignore WS
%ignore COMMENT
