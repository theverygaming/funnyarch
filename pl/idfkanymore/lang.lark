?start: (import_stmt | globalvar | procedure_def)*
?start_header: (import_stmt | globalvar_decl | procedure_decl)*

// core language

globalvar: _EXPORT? _VAR IDENTIFIER _COLON type _EQUALS (expression | array_def) _SEMICOLON

globalvar_decl: _EXTERN _VAR IDENTIFIER _COLON type _SEMICOLON

import_stmt: _IMPORT string _SEMICOLON

procedure_decl: _EXTERN procedure_prototype

procedure_def: _EXPORT? procedure_prototype procedure_def_vars? _BEGIN block _END

procedure_prototype: _PROCEDURE IDENTIFIER _LPAREN procedure_def_args _RPAREN _COLON IDENTIFIER _SEMICOLON
procedure_def_args: procedure_def_arg (_COMMA procedure_def_arg)*
procedure_def_arg: IDENTIFIER _COLON type

procedure_def_vars: _VARS procedure_def_var*
procedure_def_var: IDENTIFIER _COLON type _SEMICOLON

type: IDENTIFIER | _POINTER _TO IDENTIFIER | _ARRAY _LBRACKET NUMBER _RBRACKET _OF IDENTIFIER

array_def: _LBRACKET ( | (expression (_COMMA expression)*)) _RBRACKET

pointer_index: IDENTIFIER _LBRACKET expression _RBRACKET

// based on: https://en.cppreference.com/w/c/language/operator_precedence.html
expression: logical_or

?logical_or: logical_and
           | logical_or LOGICAL_OR logical_and -> binop

?logical_and: bitor
            | logical_and LOGICAL_AND bitor -> binop

?bitor: bitxor
      | bitor BW_OR bitxor -> binop

?bitxor: bitand
       | bitxor BW_XOR bitand -> binop

?bitand: equality
       | bitand BW_AND equality -> binop

?equality: compare 
         | equality CMP_EQ compare -> cmp
         | equality CMP_NEQ compare -> cmp

?compare: bitshift
        | compare CMP_LT bitshift -> cmp
        | compare CMP_GT bitshift -> cmp
        | compare CMP_LTEQ bitshift -> cmp
        | compare CMP_GTEQ bitshift -> cmp

?bitshift: sum
         | bitshift BW_SHIFT_LEFT sum -> binop
         | bitshift BW_SHIFT_RIGHT sum -> binop

?sum: product
    | sum PLUS product -> binop
    | sum MINUS product -> binop

?product: unary
        | product MULTIPLY unary -> binop
        | product DIVIDE unary -> binop
        | product REMAINDER unary -> binop

?unary: atom
      | BW_NOT unary -> unaryop

?atom: IDENTIFIER
     | SIGNED_NUMBER
     | pointer_index
     | procedure_call
     | _LPAREN expression _RPAREN
     | string

procedure_call: IDENTIFIER _LPAREN (expression (_COMMA expression)*)* _RPAREN

assignment: IDENTIFIER _EQUALS expression _SEMICOLON

return: _RETURN expression _SEMICOLON

while: _WHILE expression _DO block _DONE

if: _IF expression _THEN block if_elsif if_else _END

if_elsif: (_ELSIF expression _THEN block)*

if_else: (_ELSE block)?

statement: assignment | return | while | if

block: statement*

// keywords and terms and stuff

// keywords
_IMPORT: "IMPORT"
_EXTERN: "EXTERN"
_EXPORT: "EXPORT"
_VAR: "VAR"
_PROCEDURE: "PROCEDURE"
_VARS: "VARS"
_BEGIN: "BEGIN"
_END: "END"
_WHILE: "WHILE"
_DO: "DO"
_DONE: "DONE"
_IF: "IF"
_THEN: "THEN"
_ELSIF: "ELSIF"
_ELSE: "ELSE"
_RETURN: "RETURN"
_POINTER: "POINTER"
_TO: "TO"
_ARRAY: "ARRAY"
_OF: "OF"

// simple terms
_SEMICOLON: ";"
_COLON: ":"
_COMMA: ","
_LPAREN: "("
_RPAREN: ")"
_LBRACKET: "["
_RBRACKET: "]"
_EQUALS: "="
PLUS: "+"
MINUS: "-"
MULTIPLY: "*"
DIVIDE: "/"
REMAINDER: "%"
BW_SHIFT_LEFT: "<<"
BW_SHIFT_RIGHT: ">>"
BW_AND: "&"
BW_NOT: "~"
BW_OR: "|"
BW_XOR: "^"
CMP_LT: "<"
CMP_GT: ">"
CMP_LTEQ: "<="
CMP_GTEQ: ">="
CMP_EQ: "=="
CMP_NEQ: "!="
LOGICAL_AND: "&&"
LOGICAL_OR: "||"

// other stuff, no idea what u call this
IDENTIFIER: /[a-zA-Z_][a-zA-Z0-9_]*/
string: ESCAPED_STRING

// imports etc.

%import common.ESCAPED_STRING
%import common.SIGNED_NUMBER
%import common.NUMBER
%import common.WS

%ignore WS
